
#include "ContentSplitting.hpp"

#include "ResponseFileHandling.hpp"
#include "ReadFileContents.hpp"
#include "PrivateUtilities.hpp"

#include "PrivateIntrinsics.hpp"

#include <string.h>


namespace text_processing {

	namespace fs = std::filesystem;

	// -----------------------------------------------------------------------------------------

	static inline bool is_blank(const char c) {
		return c == ' ' || c == '\t';
	}

#if 0
	static inline bool is_eolz(const char c) {
		return !!memchr("\r\n", c, 3 /* including NUL */ );
	}

	static inline bool is_eol_or_blank(const char c) {
		return !!memchr("\r\n \t", c, 4);
	}
#else
	static inline bool is_eolz(const char c) {
		return c == '\r' || c == '\n' || c == '\0';
	}

	static inline bool is_eol_or_blank(const char c) {
		return c == '\r' || c == '\n' || c == ' ' || c == '\t';
	}
#endif

	// parseContentAsLines():
	// 
	// a new implementation, after discovering the inner run-until-EOL loop takes up most of the time (~50%)
	// 
	// is this ~10% faster?
	//
	// Nope. > 25% faster! (for very large files: 3GB)
	// 
	// The inner run-until-EOL loop is still the Big One(tm) but it dropped to ~40% of the total cost of the code,
	// while the outer loop has been somewhat simplified and should execute faster as well. --> it does!
	//
	// 
	// POST MORTEM NOTES:
	// smarter folks than me may be able to turn this thing into a SIMD vectorized splitter loop, but I have
	// looked at StringZilla et al and they don't provide faster implementations for the critical functionality,
	// which is equivalent to using strcspn/strspn as we scan through the content hunting for multiple specials
	// (CR, LF, TAB, ...) at any time.
	// The tightly packed actions[] lookup table was imagined as the best potential optimization approach here instead,
	// producing a code with fewer conditions, hence less chance at prediction faults and better approaching
	// branchless code.
	//
	// The stack-local and run-time generated lookup table was expected to be somewhat costly, but compared to the
	// Textbuffer sizes we're processing in the benchmark, this is utterly negligible. Of course, this may be another
	// story altogether in actually production, as we are expecting to process a lot of SMALL FILES as well!
	// --> we might gain from a singleton action table generator or static table which is generated by external tools.
	//
	// HOWEVER, do note that the stack-local action state machine is INTENTIONAL as we wish to re-use this technology
	// for our word + ngram scanners, which are expected to PATCH the action table at runtime to suit their local
	// needs, i.e. a self-modifying state machine!
	//
	void ExtendedFileContent::parseContentAsLines(const FileContentProcessingOptions& options, std::error_code &ec) {
		ec.clear();

		// prep the actions table
		enum Action: uint8_t {
			noAction = 0,
			MarkEndOfLine,
			SkipWhitespace,
			SkipCommentLine,
		};
		Action actions[256] = {MarkEndOfLine, noAction};
		if (options.trim_outer_whitespace) {
			actions['\t'] = SkipWhitespace;
			actions['\v'] = SkipWhitespace;
			actions[' '] = SkipWhitespace;
		}
		actions['\r'] = MarkEndOfLine;
		actions['\n'] = MarkEndOfLine;
		if (options.accept_comment_lines) {
			actions['#'] = SkipCommentLine;
		}

		std::string_view d = file_content.content_view();
		file_content.write_buffer_edge_sentinel();

		// apply heuristic to estimate the number of lines that will be found
		lines.reserve(d.size() / 10);

		// scan the response file:
		size_t failure_count = 0;
		const auto* ptr = d.data();
		for (size_t i = 0, l = d.size(); i < l; ) {
			uint8_t c = ptr[i++];
			switch (actions[c]) {
			case SkipWhitespace:
				while (is_blank(ptr[i])) {
					i--;
				}
				continue;

			case MarkEndOfLine:
				// end-of-line ~ empty line. ignore.
				continue;

			case SkipCommentLine:
				while (actions[ptr[i++]] != MarkEndOfLine) {
					;
				}
				continue;

			[[likely]] case noAction:
			default:
				auto start = i - 1;
				// path MAY have INTERNAL whitespace: find the terminating CR/LF/NUL
				while (actions[ptr[i++]] != MarkEndOfLine) {
					;
				}
				const auto ei = i;
				// but trim off trailing whitespace!
				// 
				//if (options.trim_outer_whitespace) {    --> only then does state `SkipWhitespace` exist in the actions table.
					while (actions[ptr[--i]] == SkipWhitespace) {
						;
					}
					i++;
				//}

				std::string_view line(ptr + start, i - start);
				assert(!line.empty());

				lines.push_back(line);

				// small aid for CRLF line terminations in files: ptr[i-1] is probably the CR, so we might speed things up
				// by quickly checking if ptr[i] is a LF:
				i = ei;
				if (actions[ptr[i]] == MarkEndOfLine) {
					++i;
				}
				continue;
			}
		}
	}


	void ExtendedFileContent::parseContentAsParagraphs(const FileContentProcessingOptions& options, std::error_code &ec) {
		ec.clear();

		std::string_view d = file_content.content_view();

		// apply heuristic to estimate the number of lines that will be found
		lines.reserve(d.size() / 10);

		// scan the response file:
		size_t failure_count = 0;
		const auto* ptr = d.data();
		for (size_t i = 0, l = d.size(); i < l; i++) {
			while (is_blank(ptr[i])) {
				i++;
			}
			switch (ptr[i]) {
			case '\r':
			case '\n':
			case 0:
				// end-of-line ~ empty line. ignore.
				continue;

			case '#':
				if (options.accept_comment_lines) {
					while (!is_eolz(ptr[i])) {
						i++;
					}
					continue;
				}
				//[[fallthrough]]
			default:
				auto start = i;
				// path MAY have INTERNAL whitespace:
				while (!is_eolz(ptr[i])) {
					i++;
				}
				i--;
				// but trim off trailing whitespace!
				while (is_blank(ptr[i])) {
					i--;
				}
				i++;

				std::string_view line(ptr + start, i - start);
				assert(!line.empty());

				lines.push_back(line);
				continue;
			}
		}
	}

	void ExtendedFileContent::parseContentAsWords(const FileContentProcessingOptions& options, std::error_code &ec) {
		ec.clear();
		return;
	}

	void ExtendedFileContent::parseContentAsNGrams(const FileContentProcessingOptions& options, std::error_code &ec) {
		ec.clear();
		return;
	}

}

